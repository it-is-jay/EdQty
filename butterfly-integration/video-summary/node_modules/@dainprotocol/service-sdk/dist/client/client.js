"use strict";
// File: src/client/client.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.DainServiceConnection = void 0;
const tslib_1 = require("tslib");
const zod_1 = require("zod");
const ai_1 = require("ai");
const axios_1 = tslib_1.__importDefault(require("axios"));
const types_1 = require("./types");
class DainServiceConnection {
    baseUrl;
    clientAuth;
    constructor(baseUrl, clientAuth) {
        this.baseUrl = baseUrl;
        this.clientAuth = clientAuth;
    }
    async makeRequest(method, path, body = {}) {
        const fullPath = `${this.baseUrl}${path}`;
        const bodyString = JSON.stringify(body);
        const { signature, timestamp } = await this.clientAuth.signRequest(method, path, bodyString);
        const response = await (0, axios_1.default)({
            method,
            url: fullPath,
            data: method === "POST" ? body : undefined,
            headers: {
                "Content-Type": "application/json",
                //  "User-Agent": "DAIN-SERVICE-CLIENT/1.0.7",
                ...this.clientAuth.getHeaders(signature, timestamp),
            },
        });
        return response.data;
    }
    async getMetadata() {
        const data = await this.makeRequest("GET", "/metadata");
        return types_1.MetadataSchema.parse(data);
    }
    async getServices() {
        const data = await this.makeRequest("GET", "/services");
        return zod_1.z.array(types_1.ServiceConfigSchema).parse(data);
    }
    async getToolboxes() {
        const data = await this.makeRequest("GET", "/toolboxes");
        return zod_1.z.array(types_1.ToolboxConfigSchema).parse(data);
    }
    async getToolbox(toolboxId) {
        const data = await this.makeRequest("GET", `/toolboxes/${toolboxId}`);
        return types_1.ToolboxConfigSchema.parse(data);
    }
    async getTools() {
        const data = await this.makeRequest("GET", "/tools");
        return zod_1.z.array(types_1.ToolConfigSchema).parse(data);
    }
    async getTool(toolId) {
        const data = await this.makeRequest("GET", `/tools/${toolId}`);
        return types_1.ToolConfigSchema.parse(data);
    }
    async getContexts() {
        const data = await this.makeRequest("GET", "/contexts");
        return zod_1.z.array(types_1.ServiceContextSchema).parse(data);
    }
    async getContext(contextId) {
        const data = await this.makeRequest("GET", `/contexts/${contextId}`);
        return types_1.ServiceContextWithDataSchema.parse(data);
    }
    async getAllContexts() {
        const data = await this.makeRequest("GET", "/getAllContexts");
        return zod_1.z.array(types_1.ServiceContextWithDataSchema).parse(data);
    }
    async getPinnables() {
        const data = await this.makeRequest("GET", "/pinnables");
        return zod_1.z.array(types_1.ServicePinnableSchema).parse(data);
    }
    async getPinnable(pinnableId) {
        const data = await this.makeRequest("GET", `/pinnables/${pinnableId}`);
        return types_1.ServicePinnableWithWidgetSchema.parse(data);
    }
    async getAllPinnables() {
        const data = await this.makeRequest("GET", "/getAllPinnables");
        return zod_1.z.array(types_1.ServicePinnableWithWidgetSchema).parse(data);
    }
    async getAllToolsAsJsonSchema() {
        const data = await this.makeRequest("GET", "/getAllToolsAsJsonSchema");
        const returned = types_1.GetAllToolsAsJsonSchemaResponseSchema.parse(data);
        return {
            tools: returned.tools,
            reccomendedPrompts: returned.reccomendedPrompts,
        };
    }
    async loadToolbox(toolboxId, execute = true) {
        const toolbox = await this.getToolbox(toolboxId);
        const tools = {};
        for (const toolId of toolbox.tools) {
            const toolInfo = await this.getTool(toolId);
            tools[toolId] = execute
                ? this.createVercelAITool(toolInfo)
                : this.createVercelAIToolWithoutExecute(toolInfo);
        }
        return tools;
    }
    createVercelAITool(toolInfo) {
        return (0, ai_1.tool)({
            description: toolInfo.description,
            parameters: this.convertSchemaToZod(toolInfo.inputSchema),
            execute: async (params) => {
                return {
                    toolInfo: toolInfo,
                    serviceInfo: await this.getMetadata(),
                    result: await this.makeRequest("POST", `/tools/${toolInfo.id}`, params),
                };
            },
        });
    }
    async callTool(toolId, params) {
        return this.makeRequest("POST", `/tools/${toolId}`, params);
    }
    async callToolAndGetNewContext(toolId, params) {
        const result = await this.makeRequest("POST", `/tools/${toolId}/executeAndGetNewContext`, params);
        return {
            toolResult: result.toolResult,
            context: result.context,
        };
    }
    createVercelAIToolWithoutExecute(toolInfo) {
        return (0, ai_1.tool)({
            description: toolInfo.description,
            parameters: this.convertSchemaToZod(toolInfo.inputSchema),
        });
    }
    convertSchemaToZod(schema) {
        switch (schema.type) {
            case "ZodObject":
                const shape = {};
                for (const [key, value] of Object.entries(schema.shape)) {
                    shape[key] = this.convertSchemaToZod(value);
                }
                return zod_1.z.object(shape).describe(schema.description || "");
            case "ZodString":
                return zod_1.z.string().describe(schema.description || "");
            case "ZodNumber":
                return zod_1.z.number().describe(schema.description || "");
            case "ZodBoolean":
                return zod_1.z.boolean().describe(schema.description || "");
            case "ZodArray":
                return zod_1.z
                    .array(this.convertSchemaToZod(schema.element))
                    .describe(schema.description || "");
            case "ZodEnum":
                return zod_1.z.enum(schema.values).describe(schema.description || "");
            case "ZodUnion":
                return zod_1.z
                    .union(schema.options.map((option) => this.convertSchemaToZod(option)))
                    .describe(schema.description || "");
            case "ZodOptional":
                return zod_1.z
                    .optional(this.convertSchemaToZod(schema.innerType))
                    .describe(schema.description || "");
            case "ZodNullable":
                return zod_1.z
                    .nullable(this.convertSchemaToZod(schema.innerType))
                    .describe(schema.description || "");
            case "ZodRecord":
                return zod_1.z
                    .record(this.convertSchemaToZod(schema.keyType), this.convertSchemaToZod(schema.valueType))
                    .describe(schema.description || "");
            case "ZodDate":
                return zod_1.z.date().describe(schema.description || "");
            case "ZodBigInt":
                return zod_1.z.bigint().describe(schema.description || "");
            case "ZodTuple":
                return zod_1.z
                    .tuple(schema.items.map((item) => this.convertSchemaToZod(item)))
                    .describe(schema.description || "");
            case "ZodIntersection":
                return zod_1.z
                    .intersection(this.convertSchemaToZod(schema.left), this.convertSchemaToZod(schema.right))
                    .describe(schema.description || "");
            case "ZodLiteral":
                return zod_1.z.literal(schema.value).describe(schema.description || "");
            case "ZodPromise":
                return zod_1.z
                    .promise(this.convertSchemaToZod(schema.type))
                    .describe(schema.description || "");
            case "ZodSet":
                return zod_1.z
                    .set(this.convertSchemaToZod(schema.valueType))
                    .describe(schema.description || "");
            case "ZodMap":
                return zod_1.z
                    .map(this.convertSchemaToZod(schema.keyType), this.convertSchemaToZod(schema.valueType))
                    .describe(schema.description || "");
            default:
                return zod_1.z.any().describe(schema.description || "Unknown type");
        }
    }
}
exports.DainServiceConnection = DainServiceConnection;
//# sourceMappingURL=client.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DainClientAuth = void 0;
const tslib_1 = require("tslib");
//File: src/client/client-auth.ts
const ed25519_1 = require("@noble/curves/ed25519");
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("@noble/hashes/utils");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
class DainClientAuth {
    privateKey;
    agentId;
    orgId;
    publicKey;
    smartAccountPDA;
    constructor(config) {
        if (config.apiKey) {
            const { privateKey, agentId, orgId, publicKey } = this.parseApiKey(config.apiKey);
            this.privateKey = privateKey;
            this.agentId = agentId;
            this.orgId = orgId;
            this.publicKey = publicKey;
        }
        else if (config.privateKeyBase58 && config.agentId && config.orgId) {
            this.privateKey = bs58_1.default.decode(config.privateKeyBase58);
            this.agentId = config.agentId.replace('agent_', '');
            this.orgId = config.orgId.replace('org_', '');
            this.publicKey = ed25519_1.ed25519.getPublicKey(this.privateKey);
        }
        else {
            throw new Error('Invalid configuration. Provide either an apiKey or privateKeyBase58, agentId, and orgId.');
        }
        this.smartAccountPDA = config.smartAccountPDA;
    }
    parseApiKey(apiKey) {
        const parts = apiKey.split('_');
        if (parts.length !== 5 || parts[0] !== 'sk' || parts[1] !== 'agent') {
            throw new Error('Invalid API key format');
        }
        const orgId = parts[2].replace('org_', '');
        const agentId = parts[3].replace('agent_', '');
        const privateKeyBase58 = parts[4];
        const privateKey = bs58_1.default.decode(privateKeyBase58).slice(0, 32);
        const publicKey = bs58_1.default.decode(privateKeyBase58).slice(32);
        return { privateKey, agentId, orgId, publicKey };
    }
    async signRequest(method, path, body) {
        const timestamp = Date.now().toString();
        const message = `${method}:${path}:${timestamp}:${body}`;
        //   console.log("signRequest:", { message, timestamp });
        const messageHash = (0, sha256_1.sha256)(message);
        const signature = ed25519_1.ed25519.sign(messageHash, this.privateKey);
        return { signature: (0, utils_1.bytesToHex)(signature), timestamp };
    }
    getHeaders(signature, timestamp) {
        return {
            "X-DAIN-SIGNATURE": signature,
            "X-DAIN-TIMESTAMP": timestamp,
            "X-DAIN-AGENT-ID": this.agentId,
            "X-DAIN-ORG-ID": this.orgId,
            "X-DAIN-ADDRESS": bs58_1.default.encode(this.publicKey),
            "X-DAIN-SMART-ACCOUNT-PDA": this.smartAccountPDA,
        };
    }
    signMessage(message) {
        const messageHash = (0, sha256_1.sha256)(message);
        const signature = ed25519_1.ed25519.sign(messageHash, this.privateKey);
        return (0, utils_1.bytesToHex)(signature);
    }
    static verifyMessage(message, signature, publicKey) {
        const messageHash = (0, sha256_1.sha256)(message);
        return ed25519_1.ed25519.verify(signature, messageHash, publicKey);
    }
    // Helper methods to get agentId, orgId, publicKey, etc.
    getAgentId() {
        return this.agentId;
    }
    getOrgId() {
        return this.orgId;
    }
    getPublicKey() {
        return this.publicKey;
    }
    getPublicKeyBase58() {
        return bs58_1.default.encode(this.publicKey);
    }
    getSmartAccountPDA() {
        return this.smartAccountPDA;
    }
}
exports.DainClientAuth = DainClientAuth;
//# sourceMappingURL=client-auth.js.map
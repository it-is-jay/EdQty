"use strict";
// File: src/service/server.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupHttpServer = setupHttpServer;
const tslib_1 = require("tslib");
const hono_1 = require("hono");
const cors_1 = require("hono/cors");
const http_exception_1 = require("hono/http-exception");
const auth_1 = require("./auth");
const schemaStructure_1 = require("../lib/schemaStructure");
const zod_to_json_schema_1 = tslib_1.__importDefault(require("zod-to-json-schema"));
function setupHttpServer(config, tools, services, toolboxes, metadata, privateKey, contexts, pinnables) {
    const app = new hono_1.Hono();
    // CORS middleware
    app.use("*", (0, cors_1.cors)({
        origin: "*",
        allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allowHeaders: [
            "X-DAIN-SIGNATURE",
            "X-DAIN-SMART-ACCOUNT-PDA",
            "X-DAIN-AGENT-ID",
            "X-DAIN-ORG-ID",
            "X-DAIN-ADDRESS",
            "X-DAIN-TIMESTAMP",
            "Content-Type",
            "Authorization",
            "Accept",
            "Origin",
            "X-Requested-With",
        ],
    }));
    // Handle OPTIONS requests for CORS pre-flight
    app.options("*", (c) => {
        return c.text("Enabling CORS Pre-Flight", 204, {
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
            "Access-Control-Allow-Headers": "X-DAIN-SIGNATURE, X-DAIN-SMART-ACCOUNT-PDA, X-DAIN-AGENT-ID, X-DAIN-ORG-ID, X-DAIN-ADDRESS, X-DAIN-TIMESTAMP, Content-Type, Authorization, Accept, Origin, X-Requested-With",
            "Access-Control-Max-Age": "86400",
        });
    });
    // Middleware to sign all responses
    app.use("*", async (c, next) => {
        await next();
        const body = await c.res.clone().text();
        const { signature, timestamp } = (0, auth_1.signResponse)(privateKey, body);
        c.res.headers.set("X-DAIN-SIGNATURE", signature);
        c.res.headers.set("X-DAIN-AGENT-ID", config.identity.agentId);
        c.res.headers.set("X-DAIN-ORG-ID", config.identity.orgId);
        c.res.headers.set("X-DAIN-ADDRESS", config.identity.publicKey);
        c.res.headers.set("X-DAIN-TIMESTAMP", timestamp);
    });
    // Middleware for signature verification
    app.use("*", async (c, next) => {
        const signature = c.req.header("X-DAIN-SIGNATURE");
        const address = c.req.header("X-DAIN-ADDRESS");
        const timestamp = c.req.header("X-DAIN-TIMESTAMP");
        const smartAccountPDA = c.req.header("X-DAIN-SMART-ACCOUNT-PDA");
        //  console.log({ signature, address, timestamp });
        if (!signature || !address || !timestamp) {
            throw new http_exception_1.HTTPException(401, {
                message: "Missing authentication headers",
            });
        }
        const method = c.req.method;
        const path = c.req.path;
        const headers = (0, auth_1.sanitizeHeaders)(c.req.header());
        const body = await c.req.text();
        if (!(0, auth_1.verifyRequestSignature)(signature, method, path, headers, body, address, smartAccountPDA)) {
            throw new http_exception_1.HTTPException(401, { message: "Invalid signature" });
        }
        await next();
    });
    async function getAgentInfo(c) {
        const smartAccountPDA = c.req.header("X-DAIN-SMART-ACCOUNT-PDA");
        const address = c.req.header("X-DAIN-ADDRESS");
        const agentId = c.req.header("X-DAIN-AGENT-ID");
        return {
            agentId: agentId,
            address: address,
            smartAccountPDA: smartAccountPDA,
            id: smartAccountPDA ? `dain_id_${smartAccountPDA}` : `address_${address}`,
        };
    }
    // Setup default ping route
    app.get("/ping", (c) => c.json({ message: "pong", platform: "DAIN", version: metadata.version }));
    // Metadata endpoint
    app.get("/metadata", (c) => c.json(metadata));
    // Tools list endpoint
    app.get("/tools", (c) => {
        const toolInfo = tools.map((tool) => ({
            id: tool.id,
            name: tool.name,
            description: tool.description,
            pricing: tool.pricing,
            inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.input),
            outputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.output),
        }));
        return c.json(toolInfo);
    });
    app.get("/contexts", (c) => {
        const contextInfo = contexts.map((context) => ({
            id: context.id,
            name: context.name,
            description: context.description,
        }));
        return c.json(contextInfo);
    });
    app.get("/contexts/:contextId", async (c) => {
        const context = contexts.find((context) => context.id === c.req.param("contextId"));
        if (context) {
            const agentInfo = await getAgentInfo(c);
            return c.json({
                id: context.id,
                name: context.name,
                description: context.description,
                data: await context.getContextData(agentInfo),
            });
        }
        else {
            throw new http_exception_1.HTTPException(404, { message: "Context not found" });
        }
    });
    app.get("/getAllContexts", async (c) => {
        const agentInfo = await getAgentInfo(c);
        const contextsFull = await Promise.all(contexts.map(async (context) => ({
            id: context.id,
            name: context.name,
            description: context.description,
            data: await context.getContextData(agentInfo),
        })));
        return c.json(contextsFull);
    });
    app.get("/pinnables", (c) => {
        const pinnableInfo = pinnables.map((pinnable) => ({
            id: pinnable.id,
            type: pinnable.type,
            label: pinnable.label,
            name: pinnable.name,
            description: pinnable.description,
            icon: pinnable.icon,
        }));
        return c.json(pinnableInfo);
    });
    app.get("/pinnables/:pinnableId", async (c) => {
        const pinnable = pinnables.find((pinnable) => pinnable.id === c.req.param("pinnableId"));
        if (pinnable) {
            const agentInfo = await getAgentInfo(c);
            const widgetData = await pinnable.getWidget(agentInfo);
            return c.json({
                id: pinnable.id,
                type: pinnable.type,
                label: pinnable.label,
                name: pinnable.name,
                description: pinnable.description,
                icon: pinnable.icon,
                widget: widgetData,
            });
        }
        else {
            throw new http_exception_1.HTTPException(404, { message: "Pinnable not found" });
        }
    });
    app.get("/getAllPinnables", async (c) => {
        const agentInfo = await getAgentInfo(c);
        const pinnablesFull = await Promise.all(pinnables.map(async (pinnable) => ({
            id: pinnable.id,
            type: pinnable.type,
            label: pinnable.label,
            name: pinnable.name,
            description: pinnable.description,
            icon: pinnable.icon,
            widget: await pinnable.getWidget(agentInfo),
        })));
        return c.json(pinnablesFull);
    });
    // Services list endpoint
    app.get("/services", (c) => {
        const serviceInfo = services.map((service) => ({
            id: service.id,
            name: service.name,
            description: service.description,
            metadata: service.metadata,
            recommendedPrompt: service.recommendedPrompt,
            recommendedTools: service.recommendedTools.map((toolId) => {
                const tool = tools.find((t) => t.id === toolId);
                return tool ? { id: tool.id, name: tool.name } : toolId;
            }),
        }));
        return c.json(serviceInfo);
    });
    // Toolboxes list endpoint
    app.get("/toolboxes", (c) => c.json(toolboxes));
    // Automatically create routes for each tool
    tools.forEach((tool) => {
        app.post(`/tools/${tool.id}`, async (c) => {
            try {
                const agentInfo = await getAgentInfo(c);
                console.log("tool.id", tool.id);
                const body = await c.req.json();
                console.log("agentInfo", body);
                const result = await tool.handler({ ...body, DAIN_EXTRA_DATA: undefined }, agentInfo, body.DAIN_EXTRA_DATA);
                return c.json(result);
            }
            catch (error) {
                console.error(`Error executing tool ${tool.id}:`, error);
                throw new http_exception_1.HTTPException(500, { message: "Internal server error" });
            }
        });
    });
    // create full context routes for all tools
    tools.forEach((tool) => {
        app.post(`/tools/${tool.id}/executeAndGetNewContext`, async (c) => {
            try {
                const agentInfo = await getAgentInfo(c);
                const body = await c.req.json();
                const result = await tool.handler({ ...body, DAIN_EXTRA_DATA: undefined }, agentInfo, body.DAIN_EXTRA_DATA);
                let contextsNow = await Promise.all(contexts.map(async (context) => ({
                    id: context.id,
                    name: context.name,
                    description: context.description,
                    data: await context.getContextData(agentInfo)
                })));
                return c.json({
                    toolResult: result,
                    context: contextsNow,
                });
            }
            catch (error) {
                console.error(`Error executing tool ${tool.id}:`, error);
                throw new http_exception_1.HTTPException(500, { message: "Internal server error" });
            }
        });
    });
    app.get("/getAllToolsAsJsonSchema", (c) => {
        const toolInfo = tools.map((tool) => ({
            id: tool.id,
            name: tool.name,
            description: tool.description,
            inputSchema: (0, zod_to_json_schema_1.default)(tool.input),
        }));
        return c.json({
            tools: toolInfo,
            reccomendedPrompts: toolboxes.map((toolbox) => toolbox.recommendedPrompt),
        });
    });
    // Detailed info for a specific tool
    app.get("/tools/:toolId", (c) => {
        const tool = tools.find((t) => t.id === c.req.param("toolId"));
        if (tool) {
            const toolDetails = {
                id: tool.id,
                name: tool.name,
                description: tool.description,
                pricing: tool.pricing,
                inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.input),
                outputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.output),
            };
            return c.json(toolDetails);
        }
        else {
            throw new http_exception_1.HTTPException(404, { message: "Tool not found" });
        }
    });
    // Detailed info for a specific service
    app.get("/services/:serviceId", (c) => {
        const service = services.find((s) => s.id === c.req.param("serviceId"));
        if (service) {
            const serviceDetails = {
                id: service.id,
                name: service.name,
                description: service.description,
                metadata: service.metadata,
                recommendedPrompt: service.recommendedPrompt,
                recommendedTools: service.recommendedTools.map((toolId) => {
                    const tool = tools.find((t) => t.id === toolId);
                    return tool
                        ? {
                            id: tool.id,
                            name: tool.name,
                            description: tool.description,
                            pricing: tool.pricing,
                            inputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.input),
                            outputSchema: (0, schemaStructure_1.getDetailedSchemaStructure)(tool.output),
                        }
                        : {
                            id: toolId,
                            name: "Unknown Tool",
                            description: "Tool not found",
                        };
                }),
            };
            return c.json(serviceDetails);
        }
        else {
            throw new http_exception_1.HTTPException(404, { message: "Service not found" });
        }
    });
    // Detailed info for a specific toolbox
    app.get("/toolboxes/:toolboxId", (c) => {
        const toolbox = toolboxes.find((t) => t.id === c.req.param("toolboxId"));
        if (toolbox) {
            return c.json(toolbox);
        }
        else {
            throw new http_exception_1.HTTPException(404, { message: "Toolbox not found" });
        }
    });
    // Health check endpoint
    app.get("/health", (c) => c.json({ status: "healthy", timestamp: new Date().toISOString() }));
    // Setup custom routes if provided
    if (config.routes) {
        config.routes(app);
    }
    return app;
}
//# sourceMappingURL=server.js.map
"use strict";
// File: src/service/core.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreUtils = void 0;
exports.createTool = createTool;
exports.createService = createService;
exports.createContext = createContext;
exports.createPinnable = createPinnable;
exports.createToolbox = createToolbox;
exports.validateAgentInfo = validateAgentInfo;
exports.calculatePrice = calculatePrice;
exports.generateId = generateId;
exports.sanitizeTags = sanitizeTags;
exports.mergeToolboxes = mergeToolboxes;
exports.validatePricing = validatePricing;
exports.isToolInToolbox = isToolInToolbox;
const zod_1 = require("zod");
function createTool(config) {
    // Validate the config
    if (!config.id || !config.name || !config.description) {
        throw new Error("Tool config is missing required fields");
    }
    // Ensure the handler respects the input and output schemas
    const wrappedHandler = async (input, agentInfo, extraData) => {
        let parsedInput;
        try {
            parsedInput = config.input.parse(input);
        }
        catch (error) {
            if (error instanceof zod_1.z.ZodError) {
                const missingParams = error.issues
                    .map((issue) => issue.path.join("."))
                    .join(", ");
                if (config.handleInputError) {
                    return await config.handleInputError(error, agentInfo, extraData);
                }
                return {
                    text: `Error: Missing or invalid parameters for this tool call- '${missingParams}', Please ask the user to provide the missing values, or try again with the correct parameters.`,
                    data: {},
                    ui: {
                        type: "error",
                        message: `Please provide valid values for: ${missingParams}`,
                    },
                };
            }
            throw error;
        }
        const result = await config.handler(parsedInput, agentInfo, extraData);
        return {
            text: result.text,
            data: config.output.parse(result.data),
            ui: result.ui,
            pleasePay: result.pleasePay,
        };
    };
    return {
        ...config,
        handler: wrappedHandler,
    };
}
function createService(config) {
    // Validate the config
    if (!config.id || !config.name || !config.description) {
        throw new Error("Service config is missing required fields");
    }
    // Validate metadata
    if (!config.metadata.capabilities || !config.metadata.languages) {
        throw new Error("Service metadata is incomplete");
    }
    return {
        ...config,
        recommendedTools: config.recommendedTools || [],
    };
}
function createContext(config) {
    return config;
}
function createPinnable(config) {
    return config;
}
function createToolbox(config) {
    // Validate the config
    if (!config.id ||
        !config.name ||
        !config.description ||
        !config.tools.length) {
        throw new Error("Toolbox config is missing required fields");
    }
    // Validate metadata
    if (!config.metadata.complexity || !config.metadata.applicableFields) {
        throw new Error("Toolbox metadata is incomplete");
    }
    return config;
}
// Utility function to validate agent info
function validateAgentInfo(agentInfo) {
    return !!(agentInfo.agentId && agentInfo.address);
}
// Utility function to calculate price for tool usage
function calculatePrice(pricing, usageCount) {
    return pricing.pricePerUse * usageCount;
}
// Utility function to generate a unique ID
function generateId(prefix) {
    return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
// Utility function to validate and sanitize metadata tags
function sanitizeTags(tags) {
    return tags.map((tag) => tag.toLowerCase().trim()).filter(Boolean);
}
// Utility function to merge toolboxes
function mergeToolboxes(toolboxes) {
    if (toolboxes.length === 0) {
        throw new Error("No toolboxes provided for merging");
    }
    const mergedTools = new Set();
    const mergedApplicableFields = new Set();
    toolboxes.forEach((toolbox) => {
        toolbox.tools.forEach((tool) => mergedTools.add(tool));
        toolbox.metadata.applicableFields.forEach((field) => mergedApplicableFields.add(field));
    });
    return {
        id: generateId("merged_toolbox"),
        name: "Merged Toolbox",
        description: "A toolbox merged from multiple toolboxes",
        tools: Array.from(mergedTools),
        metadata: {
            complexity: "Mixed",
            applicableFields: Array.from(mergedApplicableFields),
        },
        recommendedPrompt: "This toolbox contains a variety of tools from multiple domains.",
    };
}
// Utility function to validate pricing info
function validatePricing(pricing) {
    return pricing.pricePerUse >= 0 && !!pricing.currency;
}
// Utility function to check if a tool is part of a toolbox
function isToolInToolbox(toolId, toolbox) {
    return toolbox.tools.includes(toolId);
}
exports.CoreUtils = {
    validateAgentInfo,
    calculatePrice,
    generateId,
    sanitizeTags,
    mergeToolboxes,
    validatePricing,
    isToolInToolbox,
};
//# sourceMappingURL=core.js.map